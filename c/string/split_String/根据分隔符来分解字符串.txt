 C语言中通过分隔符来截取字符串
2010-09-05 11:29 1789人阅读 评论(0) 收藏 举报
最近在工作中要实现这样一个功能：

从一个文本文件中按行读取数据，一行数据中每一列都可能含有空格，所以你要把空格给截取出来。列之间是通过TAB键分割的。

我在一开始使用了C的库函数strtok这个函数。

先介绍一下strtok这个函数原型:

char *strtok(char *src,  char *flag)

参数一是你要截取的字符串，参数2是字符串中的分隔符。

看一下linux的man手册是如何结束这个函数的功能的：

这个函数的作用是从字符串中提取出分隔符号。

也就说一个字符串如果是用/t作为分隔符的话，你使用这个函数后得到的是一个去掉了/t的字符串，返回了这个字符串的首地址。

在字符串中原分隔符的位置，使用/0替换了原来的分隔符。所以你在使用的时候要注意了，如果你的目标字符串包含了多个分隔符，你应该这样使用这个函数：

char *tmp="abc	123		ABC";  //分隔符是/t

char *p=strtok(tmp,"/t");   //p指向了abc

char *p1=strtok(NULL, "/t");  //p1指向了123

char *p2=strtok(NULL, "/t");  //p2指向了ABC

但是如果你遇到了这样的情况，那么这个函数就不会起作用了：

 

char *tmp="abc	  	ABC";  //分隔符是/t，注意第二个是空格

char *p=strtok(tmp,"/t");   //p指向了abc

char *p1=strtok(NULL, "/t");  //p1指向了ABC,不会取出你想要的空格

char *p2=strtok(NULL, "/t");  //p2会报错的

还有就是这个函数不是线程安全的，Linux推荐使用函数strtok_r函数。

 

 

显然这个函数没有办法实现我要的功能的，于是我就自己写了一个函数来实现这个功能：

我的函数如下：

void myStrtok(char *tmp, char flag, char **p1, char **p2, char **p3)

{

//三个二级指针必须要在调用函数中定义，这样在这个函数内的赋值才能传出去。

	int i,j;

	int a[3];  //这个地方有一个不好的地方就是这个数组的定义随着截取出串的多少你需要改动，最好是自己传入一个数组，这样就好了

	char *ptr=tmp;

	while(*tmp)

	{

		if(*tmp==flag)

		{

			a[j++]=i;  //记录分割符出现的位置

			*tmp='/0'；//把原来的分割符替换为'/0'

		}

		tmp++;

		i++;

	}

	*p1=ptr;

	*p2=ptr+a[0]+1;

	*p3=ptr+a[1]+1;

}

 

在函数外部，你可以定义三个一级指针，如 char *p1, char *p2,  char *p3,

这样就可以使用了上面的函数了：

myStrtok(tmp, '/t', &p1, &p2, &p3);

这样的话，你就可以截取到每一个被分隔符分割的字符串了，包括空格.